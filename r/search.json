[{"path":"https://multi-objective.github.io/moocore/r/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Manuel López-Ibáñez. Author, maintainer.","code":""},{"path":"https://multi-objective.github.io/moocore/r/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. doi: 10.1007/978-3-642-02538-9_9","code":"@InCollection{,   title = {Exploratory Analysis of Stochastic Local Search Algorithms in Biobjective Optimization},   author = {Manuel López-Ibáñez and Luis Paquete and Thomas Stützle},   year = {2010},   doi = {10.1007/978-3-642-02538-9_9},   booktitle = {Experimental Methods for the Analysis of Optimization Algorithms},   publisher = {Springer, Berlin, Germany},   editor = {Thomas Bartz-Beielstein and Marco Chiarandini and Luís Paquete and Mike Preuss},   pages = {209--222}, }"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"moocore-core-algorithms-for-multi-objective-optimization","dir":"","previous_headings":"","what":"Core Mathematical Functions for Multi-Objective Optimization","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"[ Homepage ] [ GitHub ] Maintainer: Manuel López-Ibáñez Contributors: Manuel López-Ibáñez, Carlos M. Fonseca, Luís Paquete, Mickaël Binois.","code":""},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"empirical attainment function (EAF) describes probabilistic distribution outcomes obtained stochastic algorithm objective space. R package implements plots summary attainment surfaces differences first-order EAFs. plots may used exploring performance stochastic local search algorithms biobjective optimization problems help identifying certain algorithmic behaviors graphical way. corresponding book chapter [1] explains use visualization tools illustrates examples arising practice. addition, package provides functions computing several quality metrics, hypervolume, IGD, IGD+, epsilon. Keywords: empirical attainment function, summary attainment surfaces, EAF differences, multi-objective optimization, bi-objective optimization, performance measures, performance assessment, graphical analysis, visualization. Relevant literature: Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. (chapter also available slightly extended form Technical Report TR/IRIDIA/2009-015). [ bibtex | doi: 10.1007/978-3-642-02538-9_9 | Presentation ]","code":""},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"download-and-installation","dir":"","previous_headings":"","what":"Download and installation","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"moocore package implemented R. Therefore, basic knowledge R recommended make use features. first step installing moocore package install R. R installed system, two methods installing moocore package: Install within R (automatic download, internet connection required). Invoke R, Download moocore package CRAN (may also need download install first package modeltools), invoke command-line: <package> one three versions available: .tar.gz (Unix/BSD/GNU/Linux), .tgz (MacOS X), .zip (Windows). Search R documentation need help install R package system. code computing EAF available C program, require installing R R packages. Just download package source code, uncompress , look directory src/eaf. C code can used implement visualizations instead visualizations provided moocore package. Compiled executables computing EAF can found system.file(package=\"moocore\", \"bin\"). useful executable programs can found . moocore package also contains two Perl scripts may allow generate standard plots without R knowledge. See inst/scripts/eafplot/ inst/scripts/eafdiff/ package source code. scripts use moocore package internally generate plots, , hence, moocore package must installed working. wish notified bugfixes new versions, please subscribe low-volume emo-list, announcements made. [ Download moocore package CRAN ] [ Documentation ] [ Development version (GitHub) ]","code":"install.packages(\"moocore\") R CMD INSTALL <package>"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"github-development-version","dir":"","previous_headings":"","what":"GitHub (Development version)","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"wish try development version, can install executing following commands within R console:","code":"R> install.packages(\"devtools\")     R> devtools::install_github(\"multi-objective/moocore\")"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"moocore package installed, following R commands give information: addition, source code contains following src/: * src/eaf : C program computes empirical attainment function 2 3 dimensions. required programs, provided useful command-line utility. version based original code written Carlos M. Fonseca available http://www.tik.ee.ethz.ch/pisa/. recent version available Prof. Fonseca’s website. * src/mo-tools : Several tools working multi-objective data. information, consult README files subdirectory.","code":"library(moocore)     ?eaf     ?read_datasets"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"python","dir":"","previous_headings":"","what":"Python","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"also Python moocore package: https://multi-objective.github.io/moocore/python","code":""},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"software Copyright (C) 2011-2021 Carlos M. Fonseca, Luís Paquete, Thomas Stützle, Manuel López-Ibáñez Marco Chiarandini. program free software (software libre); can redistribute /modify terms GNU General Public License published Free Software Foundation; either version 2 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. IMPORTANT NOTE: Please aware fact program released Free Software excuse scientific propriety, obligates give appropriate credit! write scientific paper describing research made substantive use program, obligation scientist () mention fashion software used Methods section; (b) mention algorithm References section. appropriate citation : Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. doi: 10.1007/978-3-642-02538-9_9 Moreover, personal note, appreciate email manuel.lopez-ibanez@manchester.ac.uk citations papers referencing work can mention funding agent tenure committee.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data goal providing example use vorobT() vorobDev(). obtained fitting two Gaussian processes 20 observations bi-objective problem, generating conditional simulation GPs different locations extracting non-dominated values coupled simulations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"CPFs"},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data frame 2967 observations following 3 variables. f1 first objective values. f2 second objective values. set indices corresponding conditional Pareto fronts.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"M Binois, D Ginsbourger, O Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386--394. doi:10.1016/j.ejor.2014.07.032 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"data(CPFs) vorobT(CPFs, reference = c(2, 200)) #> $threshold #> [1] 44.14062 #>  #> $VE #>               [,1]      [,2] #>   [1,] -37.5978423 -10.79646 #>   [2,] -37.4804644 -11.53365 #>   [3,] -37.0991315 -13.28225 #>   [4,] -36.8538299 -13.51379 #>   [5,] -35.9143692 -15.88340 #>   [6,] -33.7273974 -16.62457 #>   [7,] -33.6535102 -16.82444 #>   [8,] -33.1511911 -18.74396 #>   [9,] -32.9692979 -18.74794 #>  [10,] -31.9646706 -18.75199 #>  [11,] -31.7587126 -19.01094 #>  [12,] -31.5938459 -19.25569 #>  [13,] -31.0546051 -19.27765 #>  [14,] -29.9981435 -19.42665 #>  [15,] -29.7032739 -19.97302 #>  [16,] -28.8450841 -19.99701 #>  [17,] -28.7662560 -20.14155 #>  [18,] -28.7604414 -20.21210 #>  [19,] -28.6222054 -20.29300 #>  [20,] -28.6081935 -20.35386 #>  [21,] -27.5789696 -20.56612 #>  [22,] -27.4631376 -20.65248 #>  [23,] -26.6204447 -20.92707 #>  [24,] -25.7823451 -20.98034 #>  [25,] -25.7284367 -21.07042 #>  [26,] -25.2472705 -21.10899 #>  [27,] -25.2011926 -21.21124 #>  [28,] -25.1393615 -21.26280 #>  [29,] -24.6906978 -21.29381 #>  [30,] -24.4908478 -21.41502 #>  [31,] -23.5137561 -21.67388 #>  [32,] -23.3115825 -21.77622 #>  [33,] -23.0923337 -21.80502 #>  [34,] -22.7120508 -21.88500 #>  [35,] -21.2422296 -21.88748 #>  [36,] -20.7717958 -21.98188 #>  [37,] -20.5216678 -22.06040 #>  [38,] -19.4227481 -22.06195 #>  [39,] -19.4154587 -22.32430 #>  [40,] -19.1464967 -22.38983 #>  [41,] -18.7563892 -22.66689 #>  [42,] -18.5288873 -22.74792 #>  [43,] -17.2773218 -22.78154 #>  [44,] -15.3792174 -22.87815 #>  [45,] -15.0369845 -22.87827 #>  [46,] -14.1304836 -22.89749 #>  [47,] -13.6576356 -22.91511 #>  [48,] -13.4737509 -23.10140 #>  [49,] -12.5828793 -23.20047 #>  [50,] -12.5806182 -23.25464 #>  [51,] -12.4567703 -23.37415 #>  [52,] -12.1855012 -23.44729 #>  [53,] -11.8617280 -23.44904 #>  [54,] -11.7554838 -23.47981 #>  [55,] -11.2052699 -23.48659 #>  [56,]  -9.5701487 -23.50222 #>  [57,]  -9.1922152 -23.56067 #>  [58,]  -9.1141942 -23.59717 #>  [59,]  -8.7050441 -23.69267 #>  [60,]  -8.4556581 -23.88606 #>  [61,]  -8.2849670 -24.06901 #>  [62,]  -8.2392877 -24.09147 #>  [63,]  -8.0321385 -24.09929 #>  [64,]  -7.8725159 -24.12909 #>  [65,]  -7.4508325 -24.14180 #>  [66,]  -7.4474946 -24.19948 #>  [67,]  -7.2977411 -24.24551 #>  [68,]  -6.9845013 -24.27163 #>  [69,]  -6.8595590 -24.30992 #>  [70,]  -6.8388461 -24.38878 #>  [71,]  -6.2772159 -24.39190 #>  [72,]  -6.2175064 -24.41195 #>  [73,]  -6.0638418 -24.42932 #>  [74,]  -5.5502105 -24.45534 #>  [75,]  -5.0101700 -24.48061 #>  [76,]  -4.3447716 -24.50950 #>  [77,]  -3.0751063 -24.70106 #>  [78,]  -3.0329554 -24.81540 #>  [79,]  -2.7721849 -24.88356 #>  [80,]  -2.2829770 -24.95552 #>  [81,]  -1.9772500 -24.98507 #>  [82,]  -1.8284903 -25.09108 #>  [83,]  -1.7979003 -25.19219 #>  [84,]  -1.7099778 -25.27572 #>  [85,]  -0.3551225 -25.45475 #>  [86,]   1.4752205 -25.47433 #>  [87,]   1.6394106 -25.65990 #>  [88,]   2.1632632 -25.95665 #>  [89,]   3.3794879 -26.09472 #>  [90,]   3.5055396 -26.15303 #>  [91,]   3.8248183 -26.24308 #>  [92,]   4.0332572 -26.24397 #>  [93,]   4.1387790 -26.34159 #>  [94,]   4.3513727 -26.43825 #>  [95,]   6.3208813 -26.56214 #>  [96,]   7.2998707 -26.63191 #>  [97,]   9.3460150 -26.65485 #>  [98,]   9.5386116 -26.94045 #>  [99,]  10.3781974 -26.96751 #> [100,]  11.6804102 -26.96959 #> [101,]  14.4125986 -27.00102 #> [102,]  16.6933277 -27.01095 #> [103,]  17.8683518 -27.10385 #> [104,]  18.2756069 -27.65269 #> [105,]  19.4882347 -27.71717 #> [106,]  20.1816676 -27.89640 #> [107,]  21.3732947 -28.01213 #> [108,]  21.9884321 -28.08156 #> [109,]  22.0195376 -28.09682 #> [110,]  22.0288958 -28.26190 #> [111,]  23.3059424 -28.55590 #> [112,]  23.5153250 -28.56087 #> [113,]  24.7980488 -28.64589 #> [114,]  26.8934652 -28.66955 #> [115,]  27.0974155 -28.72620 #> [116,]  28.8806091 -28.89576 #> [117,]  29.0315353 -28.90785 #> [118,]  29.9601039 -28.93467 #> [119,]  30.5141538 -28.96768 #> [120,]  34.0007655 -29.07697 #> [121,]  34.2778379 -29.18076 #> [122,]  35.0459845 -29.26500 #> [123,]  35.8108691 -29.49194 #> [124,]  38.6075068 -29.80295 #> [125,]  39.6553751 -29.80366 #> [126,]  39.9937466 -29.81892 #> [127,]  41.0272025 -29.82227 #> [128,]  42.0504690 -29.88635 #> [129,]  45.6096523 -30.01872 #> [130,]  47.7046212 -30.02561 #> [131,]  49.2600525 -30.17545 #> [132,]  49.6427641 -30.40698 #> [133,]  53.0626287 -30.43793 #> [134,]  54.7697400 -30.50487 #> [135,]  54.9914959 -30.52316 #> [136,]  56.0850877 -30.71623 #> [137,]  56.8025563 -30.76961 #> [138,]  59.1633411 -30.92437 #> [139,]  59.5340987 -31.05449 #> [140,]  63.7214774 -31.15033 #> [141,]  63.9688708 -31.23838 #> [142,]  64.5288942 -31.31147 #> [143,]  68.2713249 -31.42743 #> [144,]  68.9108617 -31.45392 #> [145,]  69.8039471 -31.48788 #> [146,]  70.2719871 -31.50890 #> [147,]  72.6160142 -31.54263 #> [148,]  73.6628042 -31.54855 #> [149,]  73.9591043 -31.60323 #> [150,]  74.6389291 -31.64608 #> [151,]  75.2462156 -31.66217 #> [152,]  75.7353427 -31.70506 #> [153,]  76.9137031 -31.77816 #> [154,]  77.4465275 -31.80060 #> [155,]  77.5418527 -31.81632 #> [156,]  78.9251438 -31.84611 #> [157,]  79.5251958 -31.87112 #> [158,]  80.2261408 -31.87627 #> [159,]  81.1123543 -31.88464 #> [160,]  82.0887769 -31.89967 #> [161,]  82.2917624 -32.02414 #> [162,]  83.5546447 -32.04372 #> [163,]  84.1241591 -32.11488 #> [164,]  85.1042890 -32.29158 #> [165,]  85.9680606 -32.42294 #> [166,]  87.5788795 -32.43134 #> [167,]  88.3184250 -32.47432 #> [168,]  89.3680488 -32.47811 #> [169,]  90.9786234 -32.49957 #> [170,]  91.2025371 -32.52547 #> [171,]  92.6006520 -32.53529 #> [172,]  94.4332216 -32.58076 #> [173,]  95.4272615 -32.64220 #> [174,]  96.4968088 -32.65060 #> [175,]  97.8282433 -32.67302 #> [176,]  98.7716071 -32.71148 #> [177,] 100.5973901 -32.74339 #> [178,] 101.0167180 -32.84149 #> [179,] 102.0021813 -32.85672 #> [180,] 102.7220666 -32.87607 #> [181,] 103.0142379 -32.89849 #> [182,] 104.7393644 -32.93105 #> [183,] 104.8689570 -32.95066 #> [184,] 105.5736765 -33.07372 #> [185,] 106.4822534 -33.08142 #> [186,] 106.9804743 -33.14618 #> [187,] 107.2773119 -33.18751 #> [188,] 108.7657769 -33.20285 #> [189,] 109.0124631 -33.21556 #> [190,] 111.2330616 -33.24898 #> [191,] 111.4303834 -33.26963 #> [192,] 111.5961914 -33.28785 #> [193,] 117.1455263 -33.31951 #> [194,] 117.5839258 -33.37224 #> [195,] 117.7582125 -33.37834 #> [196,] 118.2947053 -33.38737 #> [197,] 118.5338082 -33.43432 #> [198,] 119.5898708 -33.44875 #> [199,] 122.0554270 -33.45548 #> [200,] 123.9807878 -33.48766 #> [201,] 124.4892353 -33.50264 #> [202,] 124.8585753 -33.51050 #> [203,] 127.1357276 -33.51250 #> [204,] 128.3280870 -33.57118 #> [205,] 129.3665563 -33.57142 #> [206,] 129.9706893 -33.61145 #> [207,] 131.7867643 -33.61878 #> [208,] 134.6726692 -33.66297 #> [209,] 135.3907127 -33.67311 #> [210,] 138.4449707 -33.69634 #> [211,] 138.5130531 -33.69958 #> [212,] 139.4607302 -33.73302 #> [213,] 168.0747723 -33.76486 #>  #> $avg_hyp #> [1] 8943.333 #>"},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"Results Hybrid GA Vanzyl Richmond water networks","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"","code":"HybridGA"},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"list two data frames, three columns, produced read_datasets(). $vanzyl data frame results Vanzyl network $richmond data frame results Richmond network. second column filled NA","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044. .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"","code":"data(HybridGA) print(HybridGA$vanzyl) #>       V1 V2 #> 1 347.10  4 #> 2 352.06  3 #> 3 352.15  4 #> 4 344.43  5 #> 5 344.81  4 #> 6 354.79  5 #> 7 344.74  5 print(HybridGA$richmond) #>     V1 V2 #> 1  101 NA #> 2  104 NA #> 3  100 NA #> 4   97 NA #> 5   97 NA #> 6  101 NA #> 7  101 NA #> 8   99 NA #> 9   98 NA #> 10  98 NA"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"Results SPEA2 minimising electrical cost maximising minimum idle time pumps Richmond water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"SPEA2minstoptimeRichmond"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"data frame produced read_datasets(). second column measures time seconds corresponds maximisation problem.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"data(HybridGA) data(SPEA2minstoptimeRichmond) SPEA2minstoptimeRichmond[,2] <- SPEA2minstoptimeRichmond[,2] / 60 # eafplot (SPEA2minstoptimeRichmond, xlab = expression(C[E]), #          ylab = \"Minimum idle time (minutes)\", maximise = c(FALSE, TRUE), #          las = 1, log = \"y\", legend.pos = \"bottomright\")"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"Results SPEA2 relative time-controlled triggers Richmond water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"","code":"SPEA2relativeRichmond"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"data frame produced read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"","code":"data(HybridGA) data(SPEA2relativeRichmond)"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"Results SPEA2 relative time-controlled triggers Vanzyl's water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"","code":"SPEA2relativeVanzyl"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"data frame produced read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. http://researchrepository.napier.ac.uk/id/eprint/3044.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"","code":"data(HybridGA) data(SPEA2relativeVanzyl)"},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":null,"dir":"Reference","previous_headings":"","what":"Vorob'ev computations — vorobT","title":"Vorob'ev computations — vorobT","text":"Compute Vorob'ev threshold, expectation deviation. Also, displaying symmetric deviation function possible.  symmetric deviation function probability given target objective space belong symmetric difference Vorob'ev expectation realization (random) attained set.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vorob'ev computations — vorobT","text":"","code":"vorobT(x, sets, reference, maximise = FALSE)  vorobDev(x, sets, reference, VE = NULL, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vorob'ev computations — vorobT","text":"x Either matrix data values, data frame, list data frames exactly three columns.  third column gives set (run, sample, ...) identifier. sets vector indicates set point x. missing, last column x used instead. reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. VE Vorob'ev expectation, e.g., returned vorobT().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vorob'ev computations — vorobT","text":"vorobT returns list elements threshold, VE, avg_hyp (average hypervolume) vorobDev returns Vorob'ev deviation.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vorob'ev computations — vorobT","text":"M Binois, D Ginsbourger, O Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386--394. doi:10.1016/j.ejor.2014.07.032 . C. Chevalier (2013), Fast uncertainty reduction strategies relying Gaussian process models, University Bern, PhD thesis. Ilya Molchanov (2005). Theory Random Sets. Springer.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vorob'ev computations — vorobT","text":"Mickael Binois","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vorob'ev computations — vorobT","text":"","code":"data(CPFs) res <- vorobT(CPFs, reference = c(2, 200)) res$threshold #> [1] 44.14062 res$avg_hyp #> [1] 8943.333 ## Display Vorob'ev expectation and attainment function # First style # eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 25, 50, 75, 100, res$threshold), #         main = substitute(paste(\"Empirical attainment function, \",beta,\"* = \", a, \"%\"), #                           list(a = formatC(res$threshold, digits = 2, format = \"f\")))) # # # Second style # eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 20, 40, 60, 80, 100), #         col = gray(seq(0.8, 0.1, length.out = 6)^0.5), type = \"area\", #         legend.pos = \"bottomleft\", extra.points = res$VE, extra.col = \"cyan\", #         extra.legend = \"VE\", extra.lty = \"solid\", extra.pch = NA, extra.lwd = 2, #         main = substitute(paste(\"Empirical attainment function, \",beta,\"* = \", a, \"%\"), #                           list(a = formatC(res$threshold, digits = 2, format = \"f\")))) # Now print Vorob'ev deviation VD <- vorobDev(CPFs, VE = res$VE, reference = c(2, 200)) VD #> [1] 3017.13"},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert input to a matrix with ","title":"Convert input to a matrix with ","text":"Convert input matrix \"double\" storage mode (base::storage.mode()).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert input to a matrix with ","text":"","code":"as_double_matrix(x)"},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert input to a matrix with ","text":"x (data.frame()|matrix()) numerical data frame matrix least 1 row 2 columns.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert input to a matrix with ","text":"x coerced numerical matrix().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"Convert list attainment surfaces single EAF data.frame.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"","code":"attsurf2df(x)"},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"x (list()) List data.frames matrices. names list give percentiles attainment surfaces.  format returned eaf_as_list() mooplot::eafplot().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"data.frame many columns objectives additional column percentiles.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"","code":"data(SPEA2relativeRichmond) attsurfs <- eaf_as_list(eaf(SPEA2relativeRichmond, percentiles = c(0,50,100))) str(attsurfs) #> List of 3 #>  $ 0  : num [1:7, 1:2] 90 90.3 91.9 93.1 98 ... #>  $ 50 : num [1:7, 1:2] 95.1 95.2 97.2 98.2 103.2 ... #>  $ 100: num [1:5, 1:2] 100 101 102 104 112 ... eaf_df <- attsurf2df(attsurfs) str(eaf_df) #>  num [1:19, 1:3] 90 90.3 91.9 93.1 98 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"\" \"\" \"percentiles\" # attsurfs <- eafplot (SPEA2relativeRichmond, percentiles = c(0,50,100), #                      xlab = expression(C[E]), ylab = \"Total switches\", #                      lty=0, pch=21, xlim = c(90, 140), ylim = c(0, 25)) # attsurfs <- attsurf2df(attsurfs) # text(attsurfs[,1:2], labels = attsurfs[,3], adj = c(1.5,1.5))"},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively choose according to empirical attainment function differences — choose_eafdiff","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"Interactively choose according empirical attainment function differences","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"","code":"choose_eafdiff(x, left = stop(\"'left' must be either TRUE or FALSE\"))"},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"x (matrix()) Matrix rectangles representing EAF differences returned eafdiff() rectangles=TRUE. left (logical(1)) left=TRUE return rectangles positive differences, otherwise return negative differences differences converted positive.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"matrix first 4 columns give coordinates two corners rectangle last column. cases, last column gives positive differences favor chosen side.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"","code":"# \\donttest{ extdata_dir <- system.file(package=\"moocore\", \"extdata\") A1 <- read_datasets(file.path(extdata_dir, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_dir, \"wrots_l10w100_dat\")) # Choose A1 rectangles <- eafdiff(A1, A2, intervals = 5, rectangles = TRUE) rectangles <- choose_eafdiff(rectangles, left = TRUE) reference <- c(max(A1[, 1], A2[, 1]), max(A1[, 2], A2[, 2])) x <- split.data.frame(A1[,1:2], A1[,3]) hv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  hypervolume, reference=reference) hv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  hypervolume, reference=reference) print(fivenum(hv_A1)) #>           41           67            5           89           86  #> 785206811240 798074793438 802769574696 810246464630 827967721404  print(fivenum(hv_A2)) #>           29           46           24           74           70  #> 814132427856 820458749530 823618555606 826673145848 836333173304  whv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) whv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) print(fivenum(whv_A1)) #>          58           9          78           4          16  #>  1891625587  6232795880  8278480355  9995743574 15230375078  print(fivenum(whv_A2)) #>          84          20          65           5          10  #>   906264527  2827084909  4651576336  6792802423 11748787068  # }"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"eaf() performs checks transform input output. function used packages want avoid redundant checks transformations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"","code":"compute_eaf_call(x, cumsizes, percentiles)"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"x (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. sets missing, last column x gives sets. cumsizes Cumulative size different sets points x. percentiles (numeric()) Vector indicating percentiles computed. NULL computes .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"eafdiff() performs checks transform input output. function used packages want avoid redundant checks transformations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"","code":"compute_eafdiff_call(x, y, cumsizes_x, cumsizes_y, intervals, ret)"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"x, y Data frames corresponding input data left right sides, respectively. data frame least three columns, third one set point. See also read_datasets(). cumsizes_x, cumsizes_y Cumulative size different sets points x. intervals (integer(1))  absolute range differences \\([0, 1]\\) partitioned number intervals provided. ret (\"points\"|\"rectangles\"|\"polygons\") format returned EAF differences.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact computation of the EAF in 2D or 3D — eaf","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"function computes EAF given set 2D 3D points vector set indicates set point belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"","code":"eaf(x, sets, percentiles = NULL, maximise = FALSE, groups = NULL)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"x (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. sets missing, last column x gives sets. sets vector indicates set point x. missing, last column x used instead. percentiles (numeric()) Vector indicating percentiles computed. NULL computes . maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. groups Indicates EAF must computed separately data belonging different groups.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"data frame (data.frame) containing exact representation EAF. last column gives percentile corresponds point. groups NULL, additional column indicates group point belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"several examples data sets system.file(package=\"moocore\",\"extdata\").  current implementation supports two three dimensional points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"Viviane Grunert da Fonseca, Carlos M. Fonseca, Andreia O. Hall (2001). “Inferential Performance Assessment Stochastic Optimisers Attainment Function.” Eckart Zitzler, Kalyanmoy Deb, Lothar Thiele, Carlos . Coello Coello, David Corne (eds.), Evolutionary Multi-criterion Optimization, EMO 2001, volume 1993 Lecture Notes Computer Science, 213--225. Springer, Heidelberg, Germany. doi:10.1007/3-540-44719-9_15 . Carlos M. Fonseca, Andreia P. Guerreiro, Manuel López-Ibáñez, Luís Paquete (2011). “Computation Empirical Attainment Function.” R H C Takahashi,  others (eds.), Evolutionary Multi-criterion Optimization, EMO 2011, volume 6576 Lecture Notes Computer Science, 106--120. Springer, Heidelberg. doi:10.1007/978-3-642-19893-9_8 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact computation of the EAF in 2D or 3D — eaf","text":"","code":"extdata_path <- system.file(package=\"moocore\", \"extdata\")  x <- read_datasets(file.path(extdata_path, \"example1_dat\")) # Compute full EAF (sets is the last column) str(eaf(x)) #>  num [1:215, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  # Compute only best, median and worst str(eaf(x[,1:2], sets = x[,3], percentiles = c(0, 50, 100))) #>  num [1:50, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  x <- read_datasets(file.path(extdata_path, \"spherical-250-10-3d.txt\")) y <- read_datasets(file.path(extdata_path, \"uniform-250-10-3d.txt\")) x <- rbind(data.frame(x, groups = \"spherical\"),            data.frame(y, groups = \"uniform\")) # Compute only median separately for each group z <- eaf(x[,1:3], sets = x[,4], groups = x[,5], percentiles = 50) str(z) #> 'data.frame':\t12650 obs. of  5 variables: #>  $ X1    : num  0.865 0.787 0.682 0.739 0.865 ... #>  $ X2    : num  0.966 0.966 0.997 0.966 0.926 ... #>  $ X3    : num  0.00264 0.00421 0.00483 0.00449 0.00421 ... #>  $ X4    : num  50 50 50 50 50 50 50 50 50 50 ... #>  $ groups: chr  \"spherical\" \"spherical\" \"spherical\" \"spherical\" ... # library(plotly) # plot_ly(z, x = ~X1, y = ~X2, z = ~X3, color = ~groups, #         colors = c('#BF382A', '#0C4B8E')) %>% add_markers()"},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"Convert EAF data frame list data frames, element list one attainment surface. function attsurf2df() can used convert list single data frame.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"","code":"eaf_as_list(eaf)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"eaf (data.frame()|matrix()) Data frame matrix represents EAF.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"(list()) list data frames. data.frame represents one attainment surface.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"","code":"extdata_path <- system.file(package=\"moocore\", \"extdata\") x <- read_datasets(file.path(extdata_path, \"example1_dat\")) attsurfs <- eaf_as_list(eaf(x, percentiles = c(0, 50, 100))) str(attsurfs) #> List of 3 #>  $ 0  : num [1:9, 1:2] 5128176 5134240 5142568 5144532 5155408 ... #>  $ 50 : num [1:25, 1:2] 5135414 5136906 5137952 5143188 5146024 ... #>  $ 100: num [1:16, 1:2] 5153534 5155512 5155716 5158466 5160938 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute empirical attainment function differences — eafdiff","title":"Compute empirical attainment function differences — eafdiff","text":"Calculate differences empirical attainment functions two data sets.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"eafdiff(x, y, intervals = NULL, maximise = FALSE, rectangles = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute empirical attainment function differences — eafdiff","text":"x, y Data frames corresponding input data left right sides, respectively. data frame least three columns, third one set point. See also read_datasets(). intervals (integer(1))  absolute range differences \\([0, 1]\\) partitioned number intervals provided. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. rectangles TRUE, output form rectangles color.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute empirical attainment function differences — eafdiff","text":"rectangle=FALSE, data.frame containing points transition value EAF differences.  rectangle=TRUE, matrix first 4 columns give coordinates two corners rectangle. cases, last column gives difference terms sets x minus sets y attain point (.e., negative values differences favour y).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute empirical attainment function differences — eafdiff","text":"function calculates differences EAFs two data sets.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"A1 <- read_datasets(text='  3 2  2 3   2.5 1  1 2   1 2 ')  A2 <- read_datasets(text='  4 2.5  3 3  2.5 3.5   3 3  2.5 3.5   2 1 ') d <- eafdiff(A1, A2) str(d) #>  num [1:9, 1:3] 1 2 2.5 2 2 3 2.5 3 4 2 ...          d #>       [,1] [,2] [,3] #>  [1,]  1.0  2.0    2 #>  [2,]  2.0  1.0   -1 #>  [3,]  2.5  1.0    0 #>  [4,]  2.0  2.0    1 #>  [5,]  2.0  3.0    2 #>  [6,]  3.0  2.0    2 #>  [7,]  2.5  3.5    0 #>  [8,]  3.0  3.0    0 #>  [9,]  4.0  2.5    1  d <- eafdiff(A1, A2, rectangles = TRUE) str(d) #>  num [1:9, 1:5] 2 1 2.5 2 2 2 3 3 4 1 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:5] \"xmin\" \"ymin\" \"xmax\" \"ymax\" ... d #>       xmin ymin xmax ymax diff #>  [1,]  2.0  1.0  2.5  2.0   -1 #>  [2,]  1.0  2.0  2.0  Inf    2 #>  [3,]  2.5  1.0  Inf  2.0    0 #>  [4,]  2.0  2.0  3.0  3.0    1 #>  [5,]  2.0  3.5  2.5  Inf    2 #>  [6,]  2.0  3.0  3.0  3.5    2 #>  [7,]  3.0  2.5  4.0  3.0    2 #>  [8,]  3.0  2.0  Inf  2.5    2 #>  [9,]  4.0  2.5  Inf  3.0    1"},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":null,"dir":"Reference","previous_headings":"","what":"Epsilon metric — epsilon","title":"Epsilon metric — epsilon","text":"Computes epsilon metric, either additive multiplicative.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epsilon metric — epsilon","text":"","code":"epsilon_additive(data, reference, maximise = FALSE)  epsilon_mult(data, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epsilon metric — epsilon","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (matrix | data.frame)  Reference set matrix data.frame numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epsilon metric — epsilon","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Epsilon metric — epsilon","text":"epsilon metric set \\(\\) respect reference set \\(R\\) defined $$epsilon(,R) = \\max_{r \\R} \\min_{\\} \\max_{1 \\leq \\leq n} epsilon(a_i, r_i)$$ \\(\\) \\(b\\) objective vectors , case minimization objective \\(\\), \\(epsilon(a_i,b_i)\\) computed \\(a_i/b_i\\) multiplicative variant (respectively, \\(a_i - b_i\\) additive variant), whereas case maximization objective \\(\\), \\(epsilon(a_i,b_i) = b_i/a_i\\) multiplicative variant (respectively, \\(b_i - a_i\\) additive variant). allows computing single value problems objectives maximized others minimized. Moreover, lower value corresponds better approximation set, independently type problem (minimization, maximization mixed). However, meaning value different objective type. example, imagine objective 1 minimized objective 2 maximized, multiplicative epsilon computed \\(epsilon(,R) = 3\\). means \\(\\) needs multiplied 1/3 \\(a_1\\) values 3 \\(a_2\\) values order weakly dominate \\(R\\). computation multiplicative version negative values make sense. Computation epsilon indicator requires \\(O(n \\cdot || \\cdot |R|)\\), \\(n\\) number objectives (dimension vectors).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Epsilon metric — epsilon","text":"Eckart Zitzler, Lothar Thiele, Marco Laumanns, Carlos M. Fonseca, Viviane Grunert da Fonseca (2003). “Performance Assessment Multiobjective Optimizers: Analysis Review.” IEEE Transactions Evolutionary Computation, 7(2), 117--132.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Epsilon metric — epsilon","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epsilon metric — epsilon","text":"","code":"# Fig 6 from Zitzler et al. (2003). A1 <- matrix(c(9,2,8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A2 <- matrix(c(8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A3 <- matrix(c(10,4,9,5,8,6,7,7,6,8), ncol=2, byrow=TRUE) if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(A1, xlab=expression(f[1]), ylab=expression(f[2]),         panel.first=grid(nx=NULL), pch=4, cex=1.5, xlim = c(0,10), ylim=c(0,8))    points(A2, pch=0, cex=1.5)    points(A3, pch=1, cex=1.5)    legend(\"bottomleft\", legend=c(\"A1\", \"A2\", \"A3\"), pch=c(4,0,1),           pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2) }  epsilon_mult(A1, A3) # A1 epsilon-dominates A3 => e = 9/10 < 1 #> [1] 0.9 epsilon_mult(A1, A2) # A1 weakly dominates A2 => e = 1 #> [1] 1 epsilon_mult(A2, A1) # A2 is epsilon-dominated by A1 => e = 2 > 1 #> [1] 2  # A more realistic example extdata_path <- system.file(package=\"moocore\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) epsilon_additive(A1, ref) #> [1] 199090640 epsilon_additive(A2, ref) #> [1] 132492066 # Multiplicative version of epsilon metric ref <- filter_dominated(rbind(A1, A2)) epsilon_mult(A1, ref) #> [1] 1.054015 epsilon_mult(A2, ref) #> [1] 1.023755"},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":null,"dir":"Reference","previous_headings":"","what":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"Two metaheuristic algorithms, TabuCol (Hertz de Werra 1987)  simulated annealing (Johnson et al. 1991) , find good approximation chromatic number two random graphs. data goal providing example use mooplot::eafplot() comparing algorithm performance respect time quality modelled two objectives trade .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"","code":"gcp2x2"},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"data frame 3133 observations following 6 variables. alg factor levels SAKempeFI TSinN1 inst factor levels DSJC500.5 DSJC500.9. Instances taken DIMACS repository. run numeric vector indicating run observation belong. best numeric vector indicating best solution number colors found corresponding run time. time numeric vector indicating time since beginning run observation. rescaling applied. titer numeric vector indicating iteration number corresponding observations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"Marco Chiarandini (2005). Stochastic Local Search Methods Highly Constrained Combinatorial Optimisation Problems. Ph.D. thesis, FB Informatik, TU Darmstadt, Germany.  (page 138)","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"algorithm run 10 times per graph registering time iteration number new best solution found. time limit corresponding 500*10^5 total iterations TabuCol imposed. time normalized scale 0 1 make instance independent.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"Hertz, D de Werra (1987). “Using Tabu Search Techniques Graph Coloring.” Computing, 39(4), 345--351. David S. Johnson, Cecilia R. Aragon, Lyle . McGeoch, Catherine Schevon (1991). “Optimization Simulated Annealing: Experimental Evaluation: Part II, Graph Coloring Number Partitioning.” Operations Research, 39(3), 378--406.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/gcp2x2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metaheuristics for solving the Graph Vertex Coloring Problem — gcp2x2","text":"","code":"data(gcp2x2)"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume contribution of a set of points — hv_contributions","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Computes hypervolume contribution point given set points respect given reference point assuming minimization objectives.  Dominated points zero contribution. Duplicated points zero contribution even dominated, removing one change hypervolume dominated remaining set.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"hv_contributions(data, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume contribution of a set of points — hv_contributions","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume contribution of a set of points — hv_contributions","text":"(numeric()) numerical vector","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Carlos M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006). “improved dimension-sweep algorithm hypervolume indicator.” Proceedings 2006 Congress Evolutionary Computation (CEC 2006), 1157--1163. IEEE Press, Piscataway, NJ. doi:10.1109/CEC.2006.1688440 . Nicola Beume, Carlos M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009). “complexity computing hypervolume indicator.” IEEE Transactions Evolutionary Computation, 13(5), 1075--1082. doi:10.1109/TEVC.2009.2015575 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume contribution of each point of the union of all sets. hv_contributions(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #>   [1]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>   [8]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [15]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [22]     0.000     4.380     0.000     0.000     0.000     0.000     0.000 #>  [29]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [36]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [43]     0.000     0.000     0.000     0.000     0.000     0.000  6397.052 #>  [50]  1945.800  3386.197     0.000     0.000     0.000     0.000     0.000 #>  [57]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [64]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [71]    26.255     0.000     0.000     0.000     0.000     0.000     0.000 #>  [78]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [85]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [92]     0.000    15.840     0.000     0.000     0.066     0.000     0.000 #>  [99]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [106]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [113]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [120]     0.000  3069.000   779.240     0.000     0.000     0.000     0.000 #> [127]     0.000     0.000     0.000     0.000     0.000 12428.431     0.000 #> [134]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [141]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [148]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [155]     0.000     0.000     0.000     0.000     0.000  2294.064     0.000 #> [162]     0.000     0.000     0.000     0.000     0.000  # Duplicated points show zero contribution above, even if not # dominated. However, filter_dominated removes all duplicates except # one. Hence, there are more points below with nonzero contribution. hv_contributions(filter_dominated(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE)),                  reference = c(250, 0), maximise = c(FALSE, TRUE)) #>  [1]      8.197  89283.920   7959.940   1945.800   8147.132     26.255 #>  [7] 255278.978   3698.640   2242.660      5.971   3069.000    779.240 #> [13]  41994.755   2294.064     73.054 193143.324"},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume metric — hypervolume","title":"Hypervolume metric — hypervolume","text":"Computes hypervolume metric respect given reference point assuming minimization objectives.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume metric — hypervolume","text":"","code":"hypervolume(data, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume metric — hypervolume","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume metric — hypervolume","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hypervolume metric — hypervolume","text":"algorithm \\(O(n^{d-2} \\log n)\\) time linear space complexity worst-case, experimental results show pruning techniques used may reduce time complexity even .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume metric — hypervolume","text":"Carlos M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006). “improved dimension-sweep algorithm hypervolume indicator.” Proceedings 2006 Congress Evolutionary Computation (CEC 2006), 1157--1163. IEEE Press, Piscataway, NJ. doi:10.1109/CEC.2006.1688440 . Nicola Beume, Carlos M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009). “complexity computing hypervolume indicator.” IEEE Transactions Evolutionary Computation, 13(5), 1075--1082. doi:10.1109/TEVC.2009.2015575 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume metric — hypervolume","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume metric — hypervolume","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume of the union of all sets. hypervolume(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #> [1] 7911376"},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Functions compute inverted generational distance (IGD IGD+) averaged Hausdorff distance nondominated sets points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"igd(data, reference, maximise = FALSE)  igd_plus(data, reference, maximise = FALSE)  avg_hausdorff_dist(data, reference, maximise = FALSE, p = 1L)"},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (matrix | data.frame)  Reference set matrix data.frame numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. p (integer(1)) Hausdorff distance parameter (default: 1L).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"(numeric(1)) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"generational distance (GD) set \\(\\) defined distance point \\(\\\\) closest point \\(r\\) reference set \\(R\\), averaged size \\(\\). Formally, $$GD_p(,R) = \\left(\\frac{1}{||}\\sum_{\\}\\min_{r\\R} d(,r)^p\\right)^{\\frac{1}{p}} $$ distance implementation Euclidean distance: $$d(,r) = \\sqrt{\\sum_{k=1}^M (a_k - r_k)^2} $$ inverted generational distance (IGD) calculated \\(IGD_p(,R) = GD_p(R,)\\). modified inverted generational distanced (IGD+) proposed Ishibuchi et al. (2015)  ensure IGD+ weakly Pareto compliant, similarly epsilon_additive() epsilon_mult(). modifies distance measure : $$d^+(r,) = \\sqrt{\\sum_{k=1}^M (\\max\\{r_k - a_k, 0\\})^2}$$ average Hausdorff distance (\\(\\Delta_p\\)) proposed Schütze et al. (2012)  calculated : $$\\Delta_p(,R) = \\max\\{ IGD_p(,R), IGD_p(R,) \\}$$ IGDX (Zhou et al. 2009)  application IGD decision vectors instead objective vectors measure closeness diversity decision space. One can use functions igd() igd_plus() (recommended) directly, just passing decision vectors data. different formulations GD IGD metrics literature differ value \\(p\\), distance metric used whether term \\(||^{-1}\\) inside () outside exponent \\(1/p\\).  GD first proposed Van Veldhuizen Lamont (1998)  \\(p=2\\) term \\(||^{-1}\\) outside exponent. IGD seems mentioned first Coello Coello Reyes-Sierra (2004) , however, people also used name D-metric concept \\(p=1\\) later papers often used IGD/GD \\(p=1\\). Schütze et al. (2012)  proposed place term \\(||^{-1}\\) inside exponent, formulation shown .  significant effect GD less IGD given constant reference set. IGD+ also follows formulation.  refer Ishibuchi et al. (2015)  Bezerra et al. (2017)  detailed historical perspective comparison various variants. Following Ishibuchi et al. (2015) , always use \\(p=1\\) implementation IGD IGD+ (1) setting used recent works; (2) makes irrelevant whether term \\(||^{-1}\\) inside outside exponent \\(1/p\\); (3) meaning IGD becomes average Euclidean distance reference point nearest objective vector). also slightly faster compute. GD never used directly compare quality approximations Pareto front, often contradicts Pareto optimality (weakly Pareto-compliant). recommend IGD+ instead IGD, since latter contradicts Pareto optimality cases (see examples ) whereas IGD+ weakly Pareto-compliant, implement IGD still popular due historical reasons. average Hausdorff distance (\\(\\Delta_p(,R)\\)) also weakly Pareto-compliant, shown examples .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Leonardo C. T. Bezerra, Manuel López-Ibáñez, Thomas Stützle (2017). “Empirical Assessment Properties Inverted Generational Distance Indicators Multi- Many-objective Optimization.” Heike Trautmann, Günter Rudolph, Kathrin Klamroth, Oliver Schütze, Margaret M. Wiecek, Yaochu Jin, Christian Grimme (eds.), Evolutionary Multi-criterion Optimization, EMO 2017,  Lecture Notes Computer Science, 31--45. Springer International Publishing, Cham, Switzerland. doi:10.1007/978-3-319-54157-0_3 . Carlos . Coello Coello, Margarita Reyes-Sierra (2004). “Study Parallelization Coevolutionary Multi-objective Evolutionary Algorithm.” Raúl Monroy, Gustavo Arroyo-Figueroa, Luis Enrique Sucar, Humberto Sossa (eds.), Proceedings MICAI, volume 2972 Lecture Notes Artificial Intelligence, 688--697. Springer, Heidelberg, Germany. Hisao Ishibuchi, Hiroyuki Masuda, Yuki Tanigaki, Yusuke Nojima (2015). “Modified Distance Calculation Generational Distance Inverted Generational Distance.” António Gaspar-Cunha, Carlos Henggeler Antunes, Carlos . Coello Coello (eds.), Evolutionary Multi-criterion Optimization, EMO 2015 Part , volume 9018 Lecture Notes Computer Science, 110--125. Springer, Heidelberg, Germany. Oliver Schütze, X Esquivel, Lara, Carlos . Coello Coello (2012). “Using Averaged Hausdorff Distance Performance Measure Evolutionary Multiobjective Optimization.” IEEE Transactions Evolutionary Computation, 16(4), 504--522. David . Van Veldhuizen, Gary B. Lamont (1998). “Evolutionary Computation Convergence Pareto Front.” John R. Koza (ed.), Late Breaking Papers Genetic Programming 1998 Conference, 221--228. Zhou, Qingfu Zhang, Yaochu Jin (2009). “Approximating set Pareto-optimal solutions decision objective spaces estimation distribution algorithm.” IEEE Transactions Evolutionary Computation, 13(5), 1167--1189. doi:10.1109/TEVC.2009.2021467 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"# Example 4 from Ishibuchi et al. (2015) ref <- matrix(c(10,0,6,1,2,2,1,6,0,10), ncol=2, byrow=TRUE) A <- matrix(c(4,2,3,3,2,4), ncol=2, byrow=TRUE) B <- matrix(c(8,2,4,4,2,8), ncol=2, byrow=TRUE) if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(ref, xlab=expression(f[1]), ylab=expression(f[2]),         panel.first=grid(nx=NULL), pch=23, bg=\"gray\", cex=1.5)    points(A, pch=1, cex=1.5)    points(B, pch=19, cex=1.5)    legend(\"topright\", legend=c(\"Reference\", \"A\", \"B\"), pch=c(23,1,19),           pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2) }  cat(\"A is better than B in terms of Pareto optimality,\\n however, IGD(A)=\",     igd(A, ref), \"> IGD(B)=\", igd(B, ref),     \"and AvgHausdorff(A)=\", avg_hausdorff_dist(A, ref),     \"> AvgHausdorff(A)=\", avg_hausdorff_dist(B, ref),     \", which both contradict Pareto optimality.\\nBy contrast, IGD+(A)=\",     igd_plus(A, ref), \"< IGD+(B)=\", igd_plus(B, ref), \", which is correct.\\n\") #> A is better than B in terms of Pareto optimality, #>  however, IGD(A)= 3.707092 > IGD(B)= 2.591483 and AvgHausdorff(A)= 3.707092 > AvgHausdorff(A)= 2.591483 , which both contradict Pareto optimality. #> By contrast, IGD+(A)= 1.482843 < IGD+(B)= 2.260113 , which is correct. # A less trivial example. extdata_path <- system.file(package=\"moocore\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) igd(A1, ref) #> [1] 91888189 igd(A2, ref) #> [1] 11351992  # IGD+ (Pareto compliant) igd_plus(A1, ref) #> [1] 82695357 igd_plus(A2, ref) #> [1] 10698269  # Average Haussdorff distance avg_hausdorff_dist(A1, ref) #> [1] 268547627 avg_hausdorff_dist(A2, ref) #> [1] 352613092"},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify largest EAF differences — largest_eafdiff","title":"Identify largest EAF differences — largest_eafdiff","text":"Given list datasets, return indexes pair largest EAF differences according method proposed Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"largest_eafdiff(x, maximise = FALSE, intervals = 5L, reference, ideal = NULL)"},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify largest EAF differences — largest_eafdiff","text":"x (list()) list matrices least 3 columns. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. intervals (integer(1))  absolute range differences \\([0, 1]\\) partitioned number intervals provided. reference (numeric())  Reference point vector numerical values. ideal (numeric())  Ideal point vector numerical values. NULL, calculated minimum (maximum maximising objective) objective data.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify largest EAF differences — largest_eafdiff","text":"(list()) list two components pair value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify largest EAF differences — largest_eafdiff","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209--1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"# FIXME: This example is too large, we need a smaller one. data(tpls50x20_1_MWT) nadir <- apply(tpls50x20_1_MWT[,2:3], 2L, max) x <- largest_eafdiff(split.data.frame(tpls50x20_1_MWT[,2:4], tpls50x20_1_MWT[, 1L]),                      reference = nadir) str(x) #> List of 2 #>  $ pair : int [1:2] 3 6 #>  $ value: num 777017"},{"path":"https://multi-objective.github.io/moocore/r/reference/moocore-package.html","id":null,"dir":"Reference","previous_headings":"","what":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","title":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","text":"Fast implementation mathematical operations performance metrics multi-objective optimization.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/moocore-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","text":"Maintainer: Manuel López-Ibáñez manuel.lopez-ibanez@manchester.ac.uk (ORCID)","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Identify nondominated points is_nondominated() remove dominated ones filter_dominated(). pareto_rank() ranks points according Pareto-optimality, also called nondominated sorting (Deb et al. 2002) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"is_nondominated(data, maximise = FALSE, keep_weakly = FALSE)  filter_dominated(data, maximise = FALSE, keep_weakly = FALSE)  pareto_rank(data, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. keep_weakly FALSE, return FALSE duplicates nondominated points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"is_nondominated returns logical vector length number rows data, TRUE means point dominated point. filter_dominated returns matrix data.frame mutually nondominated points. pareto_rank() returns integer vector length number rows data, value gives rank point.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"pareto_rank() meant used like rank(), assigns ranks according Pareto dominance. Duplicated points kept front. ncol(data) == 2, code uses \\(O(n   \\log n)\\) algorithm Jensen (2003) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Kalyanmoy Deb, Pratap, S Agarwal, T Meyarivan (2002). “fast elitist multi-objective genetic algorithm: NSGA-II.” IEEE Transactions Evolutionary Computation, 6(2), 182--197. doi:10.1109/4235.996017 . M T Jensen (2003). “Reducing run-time complexity multiobjective EAs: NSGA-II algorithms.” IEEE Transactions Evolutionary Computation, 7(5), 503--515.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"S = matrix(c(1,1,0,1,1,0,1,0), ncol = 2, byrow = TRUE) is_nondominated(S) #> [1] FALSE  TRUE FALSE  TRUE  is_nondominated(S, maximise = TRUE) #> [1]  TRUE FALSE FALSE FALSE  filter_dominated(S) #>      [,1] [,2] #> [1,]    0    1 #> [2,]    1    0  filter_dominated(S, keep_weakly = TRUE) #>      [,1] [,2] #> [1,]    0    1 #> [2,]    1    0 #> [3,]    1    0  path_A1 <- file.path(system.file(package=\"moocore\"),\"extdata\",\"ALG_1_dat.xz\") set <- read_datasets(path_A1)[,1:2] is_nondom <- is_nondominated(set) cat(\"There are \", sum(is_nondom), \" nondominated points\\n\") #> There are  583  nondominated points  if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(set, col = \"blue\", type = \"p\", pch = 20)    ndset <- filter_dominated(set)    points(ndset[order(ndset[,1]),], col = \"red\", pch = 21) }   ranks <- pareto_rank(set) if (requireNamespace(\"graphics\", quietly = TRUE)) {    colors <- colorRampPalette(c(\"red\",\"yellow\",\"springgreen\",\"royalblue\"))(max(ranks))    plot(set, col = colors[ranks], type = \"p\", pch = 20) }"},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalise points — normalise","title":"Normalise points — normalise","text":"Normalise points per coordinate range, e.g., c(1,2), minimum value correspond 1 maximum 2. bounds given, used normalisation.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalise points — normalise","text":"","code":"normalise(data, to_range = c(1, 2), lower = NA, upper = NA, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalise points — normalise","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. to_range Normalise values range. objective maximised, normalised c(to_range[1], to_range[0]) instead. lower, upper Bounds values. NA, maximum minimum values coordinate used. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalise points — normalise","text":"numerical matrix","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Normalise points — normalise","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalise points — normalise","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized head(SPEA2minstoptimeRichmond[, 1:2]) #>        V1    V2 #> 1 105.832   357 #> 2 108.187   911 #> 3 108.519  3960 #> 4 108.641  7560 #> 5 108.896 16532 #> 6 112.556 19957  head(normalise(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE))) #>            V1       V2 #> [1,] 1.044174 2.000000 #> [2,] 1.059891 1.993561 #> [3,] 1.062107 1.958126 #> [4,] 1.062921 1.916286 #> [5,] 1.064623 1.812013 #> [6,] 1.089049 1.772207  head(normalise(SPEA2minstoptimeRichmond[, 1:2], to_range = c(0,1), maximise = c(FALSE, TRUE))) #>              V1        V2 #> [1,] 0.04417408 1.0000000 #> [2,] 0.05989095 0.9935614 #> [3,] 0.06210666 0.9581256 #> [4,] 0.06292087 0.9162860 #> [5,] 0.06462270 0.8120126 #> [6,] 0.08904891 0.7722069"},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"Combine datasets x y row taking care making sets unique.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"","code":"rbind_datasets(x, y)"},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"x, y Datasets.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"dataset.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Read several data sets — read_datasets","title":"Read several data sets — read_datasets","text":"Reads text file table format creates matrix . file may contain several sets, separated empty lines. Lines starting '#' considered comments treated empty lines. function adds additional column set indicate set row belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read several data sets — read_datasets","text":"","code":"read_datasets(file, col_names, text)"},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read several data sets — read_datasets","text":"file (character()) Filename contains data.  row table appears one line file.  contain absolute path, file name relative current working directory, base::getwd().  Tilde-expansion performed supported.  Files compressed xz supported. col_names (character()) Vector optional names variables.  default use \"V\" followed column number. text (character()) file supplied , data read value text via text connection. Notice literal string can used include (small) data sets within R code.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read several data sets — read_datasets","text":"(matrix()) numerical matrix data file. extra column set added indicate set row belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Read several data sets — read_datasets","text":"several examples data sets system.file(package=\"moocore\",\"extdata\").","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Read several data sets — read_datasets","text":"known limitation input file must use newline characters native host system, otherwise , possibly silently, misinterpreted. GNU/Linux program dos2unix may used fix newline characters.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read several data sets — read_datasets","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read several data sets — read_datasets","text":"","code":"extdata_path <- system.file(package=\"moocore\",\"extdata\") A1 <- read_datasets(file.path(extdata_path,\"ALG_1_dat.xz\")) str(A1) #>  num [1:23260, 1:3] 1.23e+10 1.11e+10 1.18e+10 1.13e+10 9.80e+09 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"V1\" \"V2\" \"set\"  read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) #>      obj1 obj2 set #> [1,]    1    2   1 #> [2,]    3    4   1 #> [3,]    5    6   2 #> [4,]    7    8   2"},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":null,"dir":"Reference","previous_headings":"","what":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"Various strategies Two-Phase Local Search applied Permutation Flowshop Problem Makespan Weighted Tardiness objectives.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"","code":"tpls50x20_1_MWT"},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"data frame 1511 observations  4 variables: algorithm TPLS search strategy Makespan first objective values. WeightedTardiness second objective values. set indices corresponding conditional Pareto fronts.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"Jérémie Dubois-Lacoste, Manuel López-Ibáñez, Thomas Stützle (2011). “Improving Anytime Behavior Two-Phase Local Search.” Annals Mathematics Artificial Intelligence, 61(2), 125--154. doi:10.1007/s10472-011-9235-0 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"","code":"data(tpls50x20_1_MWT) str(tpls50x20_1_MWT) #> 'data.frame':\t1511 obs. of  4 variables: #>  $ algorithm        : chr  \"1to2\" \"1to2\" \"1to2\" \"1to2\" ... #>  $ Makespan         : num  4280 4238 4137 4024 4014 ... #>  $ WeightedTardiness: num  10231 10999 11737 14871 17825 ... #>  $ set              : num  1 1 1 1 1 1 1 1 1 1 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform matrix according to maximise parameter — transform_maximise","title":"Transform matrix according to maximise parameter — transform_maximise","text":"Transform matrix according maximise parameter","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform matrix according to maximise parameter — transform_maximise","text":"","code":"transform_maximise(x, maximise)"},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform matrix according to maximise parameter — transform_maximise","text":"x (data.frame()|matrix()) numerical matrix data.frame. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform matrix according to maximise parameter — transform_maximise","text":"x transformed every column maximise TRUE multiplied -1.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform matrix according to maximise parameter — transform_maximise","text":"","code":"x <- data.frame(f1=1:10, f2=101:110) rownames(x) <- letters[1:10] transform_maximise(x, maximise=c(FALSE,TRUE)) #>   f1   f2 #> a  1 -101 #> b  2 -102 #> c  3 -103 #> d  4 -104 #> e  5 -105 #> f  6 -106 #> g  7 -107 #> h  8 -108 #> i  9 -109 #> j 10 -110 transform_maximise(x, maximise=TRUE) #>    f1   f2 #> a  -1 -101 #> b  -2 -102 #> c  -3 -103 #> d  -4 -104 #> e  -5 -105 #> f  -6 -106 #> g  -7 -107 #> h  -8 -108 #> i  -9 -109 #> j -10 -110 x <- as.matrix(x) transform_maximise(x, maximise=c(FALSE,TRUE)) #>   f1   f2 #> a  1 -101 #> b  2 -102 #> c  3 -103 #> d  4 -104 #> e  5 -105 #> f  6 -106 #> g  7 -107 #> h  8 -108 #> i  9 -109 #> j 10 -110 transform_maximise(x, maximise=TRUE) #>    f1   f2 #> a  -1 -101 #> b  -2 -102 #> c  -3 -103 #> d  -4 -104 #> e  -5 -105 #> f  -6 -106 #> g  -7 -107 #> h  -8 -108 #> i  -9 -109 #> j -10 -110"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Return estimation hypervolume space dominated input data following procedure described Auger et al. (2009) . weight distribution describing user preferences may specified.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype(   data,   reference,   ideal,   maximise = FALSE,   dist = \"uniform\",   nsamples = 100000L,   seed = NULL,   mu = NULL )"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. reference (numeric())  Reference point vector numerical values. ideal (numeric())  Ideal point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. dist (character(1)) weight distribution type. See Details. nsamples (integer(1)) number samples Monte-Carlo sampling. seed (integer(1)) random seed. mu (numeric()) parameter weight distribution. See Details.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"current implementation supports 2 objectives. weight distribution  (Auger et al. 2009)  can provided via dist argument. ones currently supported : \"uniform\" corresponds default hypervolume (unweighted). \"point\" describes goal objective space, parameter mu gives coordinates goal. resulting weight distribution multivariate normal distribution centred goal. \"exponential\" describes exponential distribution rate parameter 1/mu, .e., \\(\\lambda = \\frac{1}{\\mu}\\).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Anne Auger, Johannes Bader, Dimo Brockhoff, Eckart Zitzler (2009). “Articulating User Preferences Many-Objective Problems Sampling Weighted Hypervolume.” Franz Rothlauf (ed.), Proceedings Genetic Evolutionary Computation Conference, GECCO 2009, 555--562. ACM Press, New York, NY.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42) #> [1] 3.99807 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42) #> [1] 3.00555 whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"exponential\", mu=0.2) #> [1] 1.14624 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"exponential\", mu=0.2) #> [1] 1.66815 whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"point\", mu=c(2.9,0.9)) #> [1] 0.64485 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"point\", mu=c(2.9,0.9)) #> [1] 4.03632"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Calculates hypervolume weighted set rectangles (zero weight outside rectangles). function total_whv_rect() calculates total weighted hypervolume hypervolume() + scalefactor * abs(prod(reference - ideal)) * whv_rect(). details computation given Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"whv_rect(data, rectangles, reference, maximise = FALSE)  total_whv_rect(   data,   rectangles,   reference,   maximise = FALSE,   ideal = NULL,   scalefactor = 0.1 )"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"data (matrix | data.frame)  Matrix data frame numerical values, row gives coordinates point. rectangles (matrix()) Weighted rectangles bias computation hypervolume. Maybe generated eafdiff() rectangles=TRUE choose_eafdiff(). reference (numeric())  Reference point vector numerical values. maximise (logical() | logical(1))  Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. ideal (numeric())  Ideal point vector numerical values. NULL, calculated minimum (maximum maximising objective) objective data. scalefactor (numeric(1)) real value within \\((0,1]\\) scales overall weight differences. parameter psi (\\(\\psi\\)) Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"TODO","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209--1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"rectangles <- as.matrix(read.table(header=FALSE, text='  1.0  3.0  2.0  Inf    1  2.0  3.5  2.5  Inf    2  2.0  3.0  3.0  3.5    3 ')) whv_rect (matrix(2, ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6) #> [1] 7  total_whv_rect (matrix(2, ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 26 total_whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 30 total_whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 37.5"},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Write data sets — write_datasets","title":"Write data sets — write_datasets","text":"Write data sets file format read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write data sets — write_datasets","text":"","code":"write_datasets(x, file = \"\")"},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write data sets — write_datasets","text":"x (matrix | data.frame)  Matrix data frame represents multiple data sets multi-dimensional points. row represent one point. last column set index. file Either character string naming file connection open writing. \"\" indicates output console.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write data sets — write_datasets","text":"","code":"x <- read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) write_datasets(x) #> # obj1\tobj2  #> 1 2 #> 3 4 #>  #> 5 6 #> 7 8"}]
